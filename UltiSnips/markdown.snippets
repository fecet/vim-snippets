global !p
import re
def first_p1_not_p2(line, p1, p2):
    p1s = re.search(p1, line)
    p2s = re.search(p2, line)
    if p1s and not p2s:
        return 1
    if p2s and not p1s:
        return -1
    if not p1s and not p2s:
        return 0
    if [x for x in re.finditer(p1, line)][0].span()[0] < [x for x in re.finditer(p2, line)][0].span()[0]:
        return 1
    else:
        return -1

def last_p1_not_p2(line, p1, p2):
    p1s = re.search(p1, line)
    p2s = re.search(p2, line)
    if p1s and not p2s:
        return 1
    if p2s and not p1s:
        return -1
    if not p1s and not p2s:
        return 0
    if [x for x in re.finditer(p1, line)][-1].span()[0] > [x for x in re.finditer(p2, line)][-1].span()[0]:
        return 1
    else:
        return -1
def math():
	if vim_left_last_p1_not_p2(r"https://www.zhihu.com/equation\?tex=\" alt=\"", r"eeimg=\"") and vim_right_first_p1_not_p2(r"eeimg=\"", r"https://www.zhihu.com/equation\?tex=\" alt=\""):
		return True
	lp = vim_left_paragraph()
	rp = vim_right_paragraph()
	lp = " ".join(lp)
	rp = " ".join(rp)
	lp = re.sub(r"(?<!\\)(\\\\)*\\$", "", lp)
	rp = re.sub(r"(?<!\\)(\\\\)*\\$", "", rp)
	tlp = re.sub(r"(?<!\\)(\\\\)*$$", "", lp)
	trp = re.sub(r"(?<!\\)(\\\\)*$$", "", rp)
	if tlp.count("$") % 2 == 1 and "$" in trp:
		return True
	if last_p1_not_p2(lp, "$$", "$") and first_p1_not_p2(rp, "$$", "$") and tlp.count("$$") % 2 == 1:
		return True
	return False
def vim_left_paragraph():
	currentlinenumber = int(vim.eval("line('.')"))
	left = vim.eval("getline('.')[0:col('.')-2]")
	lp = [left]
	for index in range(currentlinenumber-1, -1, -1):
		tline = vim.eval("getline(%d)" % index)
		if not tline.strip():
			return lp
		lp = [tline] + lp
	return lp
def vim_left_all(max_line = 100, offset = 0):
	left = vim.eval("getline('.')[:col('.')-2+(%d)]" % offset)
	content = [left]
	currentlinenumber = int(vim.eval("line('.')"))
	for index in range(currentlinenumber-1, max(0, currentlinenumber - max_line) if max_line > 0 else -1, -1):
		content.append(vim.eval('getline(%d)' % index))
	return content
def vim_right_paragraph():
	currentlinenumber = int(vim.eval("line('.')"))
	right = vim.eval("getline('.')[col('.')-1:]")
	rp = [right]
	for index in range(currentlinenumber+1, int(vim.eval("line('$')")) + 1):
		tline = vim.eval("getline(%d)" % index)
		if not tline.strip():
			return rp
		rp.append(tline)
	return rp
def vim_left_have(pattern):
	currentlinenumber = int(vim.eval("line('.')"))
	currentline = vim.eval("getline('.')")
	currentcol = int(vim.eval("col('.')"))
	left = currentline[0:currentcol-1]
	if re.fullmatch(pattern, left):
		return True
	for index in range(currentlinenumber-1, -1, -1):
		tline = vim.eval("getline(%d)" % index)
		if not tline.strip():
			return False
		if re.fullmatch(pattern, tline):
			return True
def vim_right_have(pattern):
	currentlinenumber = int(vim.eval("line('.')"))
	currentline = vim.eval("getline('.')")
	currentcol = int(vim.eval("col('.')"))
	right = currentline[currentcol-1:]
	if re.fullmatch(pattern, right):
		return True
	for index in range(currentlinenumber+1, int(vim.eval("line('$')")) + 1):
		tline = vim.eval("getline(%d)" % index)
		if not tline.strip():
			return False
		if re.fullmatch(pattern, tline):
			return True
def vim_left_last_p1_not_p2(p1, p2):
	currentlinenumber = int(vim.eval("line('.')"))
	# currentline = vim.eval("getline('.')")
	# currentcol = int(vim.eval("col('.')"))
	left = vim.eval("getline('.')[:col('.')-2]")
	p1s = re.search(p1, left)
	p2s = re.search(p2, left)
	# print(p1, left, p1s)
	# print(p2, left, p2s)
	# print("left: $%s$" % left)
	if p1s and not p2s:
		return True
	if p2s and not p1s:
		return False
	if p1s and p2s:
		return last_p1_not_p2(left, p1, p2) == 1
	else:
		for index in range(int(vim.eval("line('$')")) - 1, 0, -1):
			tline = vim.eval("getline(%d)" % index)
			if not tline.strip():
				return False
			p1s = re.search(p1, tline)
			p2s = re.search(p2, tline)
			if p1s and not p2s:
				return True
			if p2s and not p1s:
				return False
			if p1s and p2s:
				return last_p1_not_p2(tline, p1, p2) == 1
	return False
def vim_right_first_p1_not_p2(p1, p2):
	currentlinenumber = int(vim.eval("line('.')"))
	# currentline = vim.eval("getline('.')")
	# currentcol = int(vim.eval("col('.')"))
	# right = currentline[currentcol-1:]
	right = vim.eval("getline('.')[col('.')-1:]")
	p1s = re.search(p1, right)
	p2s = re.search(p2, right)
	# print(p1, right, p1s)
	# print(p2, right, p2s)
	# print("right: $%s$" % right)
	if p1s and not p2s:
		return True
	if p2s and not p1s:
		return False
	if p1s and p2s:
		return first_p1_not_p2(right, p1, p2) == 1
	else:
		for index in range(currentlinenumber+1, int(vim.eval("line('$')")) + 1):
			tline = vim.eval("getline(%d)" % index)
			if not tline.strip():
				return False
			p1s = re.search(p1, tline)
			p2s = re.search(p2, tline)
			if p1s and not p2s:
				return True
			if p2s and not p1s:
				return False
			if p1s and p2s:
				return first_p1_not_p2(tline, p1, p2) == 1
	return False
def generate_matrix(prefix, snip):
	info = snip.buffer[snip.line]
	spacelen = len(info) - len(info.lstrip())
	linfo = info[:snip.snippet_start[1]]
	rinfo = info[snip.snippet_end[1]:]
	info = info[snip.snippet_start[1]:snip.snippet_end[1]]
	# print([linfo, rinfo, info])
	if len(info) > 1 and info[1].isnumeric():
		real_shape = info[:2]
		virtual_shape = info[2:]
	else:
		real_shape = info[0]
		virtual_shape = info[1:]
	if len(real_shape) == 1:
		row_amount = int(real_shape)
		column_amount = int(real_shape)
	else:
		row_amount = int(real_shape[0])
		column_amount = int(real_shape[1])
	if len(virtual_shape) == 0:
		virtual_row_amount = "0"
		virtual_column_amount = "0"
	elif len(virtual_shape) == 1:
		virtual_row_amount = virtual_shape[0]
		virtual_column_amount = virtual_shape[0]
	else:
		virtual_row_amount = virtual_shape[0]
		virtual_column_amount = virtual_shape[1]
	snip.buffer[snip.line] = ''
	displayed = re.sub(r"\\", r"\\\\", linfo) + "\\begin{%cmatrix}\n" % prefix
	def generate_code(i, j, row, column, virtual_row, virtual_column):
		if i == 1 and j == 1:
			return ""
		else:
			code = """`!p
import re
def generate_matrix_element(i, j, row, column, virtual_row, virtual_column, ht, vt):
    vdot = False
    hdot = False
    leftp = "{"
    rightp = "}"
    # print(i, j, row, column, virtual_row, virtual_column)
    # print(ht)
    # print(vt)
    if i > 1 and ht[j].strip() == "\\cdots":
        vdot = True
    if j > 1 and vt[i].strip() == "\\vdots":
        hdot = True
    if vdot and hdot:
        return "\\ddots"
    elif vdot:
        return "\\cdots"
    elif hdot:
        return "\\vdots"
    elif i > 1 or j > 1:
        if virtual_row == "0":
            if i > 1 and j > 1:
                value = ""
                if re.sub("\d", "*", ht[1]) == re.sub("\d", "*", ht[2]) == re.sub("\d", "*", vt[2]):
                    for index in range(len(ht[1])):
                        if not ht[1][index].isnumeric():
                            value += ht[1][index]
                        else:
                            x1 = int(ht[1][index])
                            x2 = int(ht[2][index])
                            x3 = int(vt[2][index])
                            value += str((x2 - x1) * (j-1) + (x3 - x1) * (i-1) + x1)
                    return value
                elif re.match(".*[a-zA-Z]_\{11\}", ht[1]):
                    return re.sub("([a-zA-Z])_\{11\}", "\\g<1>_{" + str(i) + str(j) + "}", ht[1])
                else:
                    return ""
            elif i > 2:
                value = ""
                if re.sub("\d", "*", ht[1]) == re.sub("\d", "*", vt[2]):
                    for index in range(len(ht[1])):
                        if not ht[1][index].isnumeric():
                            value += ht[1][index]
                        else:
                            x1 = int(ht[1][index])
                            x3 = int(vt[2][index])
                            value += str((x3 - x1) * (i - 1) + x1)
                    return value
                elif re.match(".*[a-zA-Z]_\{11\}", ht[1]):
                    return re.sub("([a-zA-Z])_\{11\}", "\\g<1>_{" + str(i) + str(j) + "}", ht[1])
                else:
                    return ""
            elif j > 2:
                value = ""
                if re.sub("\d", "*", ht[1]) == re.sub("\d", "*", ht[2]):
                    for index in range(len(ht[1])):
                        if not ht[1][index].isnumeric():
                            value += ht[1][index]
                        else:
                            x1 = int(ht[1][index])
                            x2 = int(ht[2][index])
                            value += str((x2 - x1) * (j-1) + x1)
                    return value
                elif re.match(".*[a-zA-Z]_\{11\}", ht[1]):
                    return re.sub("([a-zA-Z])_\{11\}", "\\g<1>_{" + str(i) + str(j) + "}", ht[1])
                else:
                    return ""
            elif re.match(".*[a-zA-Z]_\{11\}", ht[1]):
                return re.sub("([a-zA-Z])_\{11\}", "\\g<1>_{" + str(i) + str(j) + "}", ht[1])
            else:
                return ht[1]
        else:
            vdot = False
            hdot = False
            if any([x.strip() == "\\vdots" for x in vt[:-1]]):
                hdot = True
            if any([x.strip() == "\\cdots" for x in ht[:-1]]):
                vdot = True
            flag = False
            biasandvirtualbias = False
            if i > 1 and j > 1:
                value = ""
                underline = False
                if re.sub("\d", "*", ht[1]) == re.sub("\d", "*", ht[2]) == re.sub("\d", "*", vt[2]):
                    for index in range(len(ht[1])):
                        if not ht[1][index].isnumeric():
                            value += ht[1][index]
                            biasandvirtualbias = False
                            if ht[1][index] == "_":
                                underline = True
                            else:
                                underline = False
                        else:
                            x1 = int(ht[1][index])
                            x2 = int(ht[2][index])
                            x3 = int(vt[2][index])
                            virtual_bias = ""
                            bias = x1
                            if underline and ht[1][index-1] == "_":
                                value += leftp
                            if not vdot:
                                bias += (x2 - x1) * (j - 1)
                            else:
                                bias += -(column - j) * (x2 - x1) - (x2 - x1)
                                if x2 != x1:
                                    if x2 == x1 + 1:
                                        virtual_bias += virtual_column
                                    elif x1 == x2 + 1:
                                        virtual_bias += "-" + virtual_column
                                    else:
                                        virtual_bias += str(x2 - x1) + virtual_column
                            if not hdot:
                                bias += (x3 - x1) * (i - 1)
                            else:
                                bias += -(row - i) * (x3 - x1) - (x3 - x1)
                                if x3 != x1:
                                    if x3 == x1 + 1:
                                        virtual_bias += ("+" if virtual_bias else "") + virtual_row
                                    elif x1 == x3 + 1:
                                        virtual_bias += "-" + virtual_row
                                    else:
                                        virtual_bias += ("+" if virtual_bias and x3 > x1 else "") + str(x3 - x1) + virtual_row
                            if index > 0 and ht[1][index-1].isnumeric() and (biasandvirtualbias or (bias and virtual_bias)):
                                value += ","
                            biasandvirtualbias = bias and virtual_bias
                            if bias == 0:
                                value += virtual_bias
                            else:
                                value += virtual_bias + ("+" if virtual_bias and bias > 0 else "") + str(bias)
                            if underline and (index == len(ht[1])-1 or not ht[1][index+1].isnumeric()):
                                value += rightp
                    return value
                    flag = True
            elif i > 2:
                value = ""
                underline = False
                if re.sub("\d", "*", ht[1]) == re.sub("\d", "*", vt[2]):
                    for index in range(len(ht[1])):
                        if not ht[1][index].isnumeric():
                            biasandvirtualbias = False
                            value += ht[1][index]
                            if ht[1][index] == "_":
                                underline = True
                            else:
                                underline = False
                        else:
                            x1 = int(ht[1][index])
                            x3 = int(vt[2][index])
                            virtual_bias = ""
                            bias = x1
                            if underline and ht[1][index-1] == "_":
                                value += leftp
                            if not hdot:
                                bias += (x3 - x1) * (i - 1)
                            else:
                                bias += -(row - i) * (x3 - x1) - (x3 - x1)
                                if x3 != x1:
                                    if x3 == x1 + 1:
                                        virtual_bias += ("+" if virtual_bias else "") + virtual_row
                                    elif x1 == x3 + 1:
                                        virtual_bias += "-" + virtual_row
                                    else:
                                        virtual_bias += ("+" if virtual_bias and x3 > x1 else "") + str(x3 - x1) + virtual_row
                            if index > 0 and ht[1][index-1].isnumeric() and (biasandvirtualbias or (bias and virtual_bias)):
                                value += ","
                            biasandvirtualbias = bias and virtual_bias
                            if bias == 0:
                                value += virtual_bias
                            else:
                                value += virtual_bias + ("+" if virtual_bias and bias > 0 else "") + str(bias)
                            if underline and (index == len(ht[1])-1 or not ht[1][index+1].isnumeric()):
                                value += rightp
                    return value
                    flag = True
            elif j > 2:
                value = ""
                underline = False
                if re.sub("\d", "*", ht[1]) == re.sub("\d", "*", ht[2]):
                    for index in range(len(ht[1])):
                        if not ht[1][index].isnumeric():
                            biasandvirtualbias = False
                            value += ht[1][index]
                            if ht[1][index] == "_":
                                underline = True
                            else:
                                underline = False
                        else:
                            x1 = int(ht[1][index])
                            x2 = int(ht[2][index])
                            virtual_bias = ""
                            bias = x1
                            if underline and ht[1][index-1] == "_":
                                value += leftp
                            if not vdot:
                                bias += (x2 - x1) * (j - 1)
                            else:
                                bias += -(column - j) * (x2 - x1) - (x2 - x1)
                                if x2 != x1:
                                    if x2 == x1 + 1:
                                        virtual_bias += virtual_column
                                    elif x1 == x2 + 1:
                                        virtual_bias += "-" + virtual_column
                                    else:
                                        virtual_bias += str(x2 - x1) + virtual_column
                            if index > 0 and ht[1][index-1].isnumeric() and (biasandvirtualbias or (bias and virtual_bias)):
                                value += ","
                            biasandvirtualbias = bias and virtual_bias
                            if bias == 0:
                                value += virtual_bias
                            else:
                                value += virtual_bias + ("+" if virtual_bias and bias > 0 else "") + str(bias)
                            if underline and (index == len(ht[1])-1 or not ht[1][index+1].isnumeric()):
                                value += rightp
                    return value
                    flag = True
            if not flag and re.match(".*[a-zA-Z]_\{11\}", ht[1]):
                if not vdot and not hdot:
                    return re.sub("([a-zA-Z])_\{11\}", "\\g<1>_{" + str(i) + str(j) + "}", ht[1])
                elif vdot and hdot:
                    return re.sub("([a-zA-Z])_\{11\}", "\\g<1>_{" + virtual_row + ("-" + str(row - i) if i != row else "") + "," + virtual_column + ("-" + str(column - j) if j != column else "") + "}", ht[1])
                elif vdot:
                    return re.sub("([a-zA-Z])_\{11\}", "\\g<1>_{" + str(i) + "," + virtual_column + ("-" + str(column - j) if j != column else "") + "}", ht[1])
                else:
                    return re.sub("([a-zA-Z])_\{11\}", "\\g<1>_{" + virtual_row + ("-" + str(row - i) if i != row else "") + "," + str(j) + "}", ht[1])
                flag = True
            elif not flag and (i == 1 or j == 1):
                return ht[1]
                flag = True
            if not flag:
                return ""
    else:
        return ""
snip.rv = generate_matrix_element(%d, %d, %d, %d, '%c', '%c', [%s], [%s])
`""" % (i, j, row, column, virtual_row, virtual_column, "''," + ",".join("t[%d]" % x for x in range(1, j+1)), "''," + ",".join("t[%d]" % (1 + column * (x-1)) for x in range(1, i+1)))
		return code
	if row_amount > 0 and column_amount > 0:
		displayed += " " * (4 + len(linfo)) + "$1\t" + ("& " if column_amount > 1 else "\\" * 4)
		index = 2
		for i in range(2, column_amount + 1):
			displayed += "${" + "{}".format(index) + ":" + generate_code(1, i, row_amount, column_amount, virtual_row_amount, virtual_column_amount) + "}\t" + ("& " if i < column_amount else "\\" * 4)
			index += 1
		displayed += "\n"
		for j in range(2, row_amount + 1):
			displayed += " " * (4 + len(linfo))
			for i in range(1, column_amount + 1):
				displayed += "${" + "{}".format(index) + ":" + generate_code(j, i, row_amount, column_amount, virtual_row_amount, virtual_column_amount) + "}\t" + ("& " if i < column_amount else "\\" * 4)
				index += 1
			displayed += "\n"
	displayed += " " * len(linfo) + "\\end{%cmatrix}$0" % prefix + (" " + re.sub(r"\\", r"\\\\", rinfo) if rinfo else "")
	snip.expand_anon(displayed)

endglobal

snippet help "help of sup" b
The options currently supported are: >
   b   Beginning of line - A snippet with this option is expanded only if the
       tab trigger is the first word on the line. In other words, if only
       whitespace precedes the tab trigger, expand. The default is to expand
       snippets at any position regardless of the preceding non-whitespace
       characters.

   i   In-word expansion - By default a snippet is expanded only if the tab
       trigger is the first word on the line or is preceded by one or more
       whitespace characters. A snippet with this option is expanded
       regardless of the preceding character. In other words, the snippet can
       be triggered in the middle of a word.

   w   Word boundary - With this option, the snippet is expanded if
       the tab trigger start matches a word boundary and the tab trigger end
       matches a word boundary. In other words the tab trigger must be
       preceded and followed by non-word characters. Word characters are
       defined by the 'iskeyword' setting. Use this option, for example, to
       permit expansion where the tab trigger follows punctuation without
       expanding suffixes of larger words.

   r   Regular expression - With this option, the tab trigger is expected to
       be a python regular expression. The snippet is expanded if the recently
       typed characters match the regular expression. Note: The regular
       expression MUST be quoted (or surrounded with another character) like a
       multi-word tab trigger (see above) whether it has spaces or not. A
       resulting match is passed to any python code blocks in the snippet
       definition as the local variable "match".

   t   Do not expand tabs - If a snippet definition includes leading tab
       characters, by default UltiSnips expands the tab characters honoring
       the Vim 'shiftwidth', 'softtabstop', 'expandtab' and 'tabstop'
       indentation settings. (For example, if 'expandtab' is set, the tab is
       replaced with spaces.) If this option is set, UltiSnips will ignore the
       Vim settings and insert the tab characters as is. This option is useful
       for snippets involved with tab delimited formats.

   s   Remove whitespace immediately before the cursor at the end of a line
       before jumping to the next tabstop.  This is useful if there is a
       tabstop with optional text at the end of a line.

   m   Trim all whitespaces from right side of snippet lines. Useful when
       snippet contains empty lines which should remain empty after expanding.
       Without this option empty lines in snippets definition will have
       indentation too.

   e   Custom context snippet - With this option expansion of snippet can be
       controlled not only by previous characters in line, but by any given
       python expression. This option can be specified along with other
       options, like 'b'. See |UltiSnips-custom-context-snippets| for more info.

   A   Snippet will be triggered automatically, when condition matches.
       See |UltiSnips-autotrigger| for more info.
endsnippet

snippet beamertemp "Beamer template" bA
---
title: "${1:Factors selection}"
author: Xie Zejian
institute: SUSTech
date: "${2:Dec 13,2020}"
output: 
  beamer_presentation:
    theme: "AnnArbor"
    colortheme: "dolphin"
    fonttheme: "structurebold"
    toc: true
    includes:
      in_header: "preamble.tex"
---
endsnippet

snippet essaytemp "Essay template" bA
---
title: $1
author:
  - Xie zejian
bibliography: references.bib
output:
  bookdown::pdf_document2:
    includes:
      in_header: preamble.tex
---
endsnippet

snippet cjktemp "CJK essay" bA
---
title: $1
author:
  - 谢泽健
documentclass: ctexart
output:
  rticles::ctex:
    fig_caption: yes
    number_sections: yes
    toc: yes
---
endsnippet

snippet rsetup "r chunks setup" bA
\`\`\`{r, setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE,
					  message=FALSE,
					  echo=FALSE, 
					  fig.width=8)
## collapse = TRUE
# dec = 'jpeg'
# eval = FALSE
# https://yihui.org/knitr/options/#chunk-options
library(tidyverse)
library(latex2exp)
\`\`\`
endsnippet

snippet beg "begin{} / end{}" bA
\\begin{$1}
	${2:${VISUAL}}
\\end{$1}$0
endsnippet

priority 100
snippet ... "ldots" iA
\dots
endsnippet

snippet table "Table environment" b
\begin{table}[${1:htpb}]
	\centering
	\caption{${2:caption}}
	\label{tab:${3:label}}
	\begin{tabular}{${5:c}}
	$0${5/((?<=.)c|l|r)|./(?1: & )/g}
	\end{tabular}
\end{table}
endsnippet

snippet fig "Figure environment" b
\`\`\`{r $1, fig.align = "center", fig.cap="$2", out.width = '70%'}

knitr::include_graphics("figures/$3.pdf")

\`\`\`
endsnippet




snippet pac "Package" b
\usepackage[${1:options}]{${2:package}}$0
endsnippet

context "math()"
snippet xeq "implies" Ai
\xlongequal{$1}$0
endsnippet

context "math()"
snippet x=> "implies" Ai
\xRightarrow{$1}$0
endsnippet

context "math()"
snippet => "implies" Ai
\implies
endsnippet

context "math()"
snippet x<= "implied by" Ai
\xLeftarrow{$1}
endsnippet

context "math()"
snippet <= "implied by" Ai
\impliedby
endsnippet

context "math()"
snippet xiff "iff" Ai
\xLeftrightarrow{$1}
endsnippet

context "math()"
snippet iff "iff" Ai
\iff
endsnippet

context "math()"
snippet embed "embedding" Ai
\hookrightarrow
endsnippet

context "math()"
snippet dec "embedding" Ai
\searrow
endsnippet

context "math()"
snippet inc "Description" Ai
\nearrow
endsnippet

context "math()"
snippet defe "define as" Ai
\triangleq
endsnippet

context "math()"
snippet sucs "embedding" Ai
\succsim 
endsnippet

context "math()"
snippet suc "embedding" Ai
\succ 
endsnippet

snippet kk "Math" iA
$$1$$0
endsnippet


snippet mk "Math" wA
$${1:${VISUAL}}$`!p
if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$2
endsnippet

context "math()"
snippet ali "Align" iA
\begin{aligned}
	${1:${VISUAL}}
\end{aligned}$0
endsnippet

context "math()"
snippet qt "Quotient" iA
/
endsnippet


context "math()"
snippet // "Fraction" iA
\\frac{$1}{$2}$0
endsnippet


context "math()"
snippet / "Fraction" i
\\frac{${VISUAL}}{$1}$0
endsnippet



context "math()"
snippet '((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)/' "symbol frac" wrA
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet

priority 1000
context "math()"
snippet '^.*\)/' "() frac" wrA
`!p
stripped = match.string[:-1]
depth = 0
i = len(stripped) - 1
while True:
	if stripped[i] == ')': depth += 1
	if stripped[i] == '(': depth -= 1
	if depth == 0: break;
	i-=1
snip.rv = stripped[0:i] + "\\frac{" + stripped[i+1:-1] + "}"
`{$1}$0
endsnippet


priority 1
context "math()"
snippet '([A-Za-z])(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`$0
endsnippet



priority 1
context "math()"
snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

priority 10000
snippet 'sympy(.*)sympy' "sympy" wr
`!p
from sympy import *
x, y, z, t = symbols('x y z t')
k, m, n = symbols('k m n', integer=True)
f, g, h = symbols('f g h', cls=Function)
init_printing()
snip.rv = eval('latex(' + match.group(1).replace('\\', '').replace('^', '**').replace('{', '(').replace('}', ')') + ')')
`
endsnippet

priority 1000
snippet mm "mathematicablock" wAs

$$
$1
$$
$0
endsnippet

priority 10000
snippet 'math(.*)math' "math" wr
`!p
import subprocess
code = match.group(1)
code = 'ToString[' + code + ', TeXForm]'
snip.rv = subprocess.check_output(['wolframscript', '-code', code])
`
endsnippet

context "math()"
snippet == "equals" iA

\\\\ &= 

endsnippet

context "math()"
snippet != "equals" iA
\neq 
endsnippet

context "math()"
snippet ceil "ceil" iA
\left\lceil $1 \right\rceil$0
endsnippet

context "math()"
snippet floor "floor" iA
\left\lfloor $1 \right\rfloor$0
endsnippet

context "math()"
snippet binom "floor" iA
\binom{$1}{$2}$0
endsnippet

context "math()"
snippet pmat "pmat" iA
\begin{pmatrix} $1 \end{pmatrix}$0
endsnippet

post_jump "generate_matrix('p', snip)"
context "math()"
snippet "pmat\(([1-9]{1,2}[a-zA-Z]{0,2})\)" "pmat" irw
`!p
if not snip.c:
	snip.rv = match.group(1)
`
endsnippet

post_jump "generate_matrix('b', snip)"
context "math()"
snippet "bmat\(([1-9]{1,2}[a-zA-Z]{0,2})\)" "bmat" irw
`!p
if not snip.c:
	snip.rv = match.group(1)
`
endsnippet

snippet ( "()" iA
($1)$0
endsnippet

snippet { "()" iwA
{$1}$0
endsnippet


snippet () "left( right)" iA
\left( ${1:${VISUAL}} \right)$0
endsnippet


snippet lr "left( right)" i
\left( ${1:${VISUAL}} \right)$0
endsnippet



snippet lr( "left( right)" i
\left( ${1:${VISUAL}} \right)$0
endsnippet


snippet lr| "left| right|" i
\left| ${1:${VISUAL}} \right|$0
endsnippet

snippet lr{ "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\}$0
endsnippet

snippet lrb "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\}$0
endsnippet

snippet lr[ "left[ right]" i
\left[ ${1:${VISUAL}} \right]$0
endsnippet

snippet lra "leftangle rightangle" iA
\left<${1:${VISUAL}} \right>$0
endsnippet

context "math()"
snippet sum "sum" wA
\sum_{${1:i \in I}}^{$2}$0
endsnippet

context "math()"
snippet lim "limit" w
\lim_{${1:n} \to ${2:\infty}}$0
endsnippet


context "math()"
snippet prod "product" wA
\prod_{${1:i \in I}} ${2:${VISUAL}}$0
endsnippet

context "math()"
snippet coprod "product" wA
\coprod_{${1:n=1}} ${4:${VISUAL}}$0
endsnippet

context "math()"
snippet part "partial" iA
\partial 
endsnippet


context "math()"
snippet sq "\sqrt{}" iA
\sqrt{${1:${VISUAL}}}$0
endsnippet

context "math()"
snippet sr "^2" iA
^2
endsnippet

context "math()"
snippet cb "^3" iA
^3
endsnippet

context "math()"
snippet td "to the ... power" iA
^{$1}$0
endsnippet

context "math()"
snippet __ "subscript" iA
_{$1}$0
endsnippet

context "math()"
snippet ooo "\infty" iA
\infty
endsnippet

snippet rij "mrij" i
(${1:x}_${2:n})_{${3:$2}\\in${4:\\N}}$0
endsnippet

context "math()"
snippet le "leq" iA
\le 
endsnippet

priority 10
context "math()"
snippet ge "geq" iA
\ge 
endsnippet

context "math()"
snippet lt "leq" wA
<
endsnippet

context "math()"
snippet gt "geq" wA
>
endsnippet

priority 10
context "math()"
snippet ee "geq" iA
\exists 
endsnippet

context "math()"
snippet aa "forall" iA
\forall 
endsnippet

snippet plot "Plot" w
\begin{figure}[$1]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			xmin= ${2:-10}, xmax= ${3:10},
			ymin= ${4:-10}, ymax = ${5:10},
			axis lines = middle,
		]
			\addplot[domain=$2:$3, samples=${6:100}]{$7};
		\end{axis}
	\end{tikzpicture}
	\caption{$8}
	\label{${9:$8}}
\end{figure}
endsnippet

snippet nn "Tikz node" w
\node[$5] (${1/[^0-9a-zA-Z]//g}${2}) ${3:at (${4:0,0}) }{$${1}$};
$0
endsnippet

priority 100
context "math()"
snippet "([\\|a-z|A-Z|0-9|'|_|^]*)cal" "mathcal" riA
\mathcal{${1:`!p snip.rv=match.group(1)`}}$0
endsnippet

priority 100
context "math()"
snippet "([\\|a-z|A-Z|0-9|'|_|^]*)fra" "mathcal" riA
\mathfrak{${1:`!p snip.rv=match.group(1)`}}$0
endsnippet

context "math()"
snippet xx "cross" iA
\times 
endsnippet

priority 100
context "math()"
snippet ** "cdot" iA
\cdot
endsnippet

context "math()"
snippet norm "norm" iA
\left\| ${1:\cdot} \right\|$0
endsnippet

context "math()"
snippet inx "inner product" iA
\left\langle ${1:\cdot},${2:\cdot} \right\rangle$0
endsnippet

context "math()"
snippet abs "abs value" iA
\left| ${1:\cdot} \right|$0
endsnippet


# with a space
priority 101
context "math()"
snippet '(?<!\\)(wedge|vee|sup|inf|limsup|liminf|max|oplus|otimes|equiv|ker|sim|approx|cong|perp|lor|land|asymp)' "ln" rw
\\`!p snip.rv = match.group(1)` $0
endsnippet

priority 101
context "math()"
snippet '(?<!\\)(sin|cos|arccot|cot|csc|ln|log|exp|star|circ|simeq)' "ln" rw
\\`!p snip.rv = match.group(1)`$0
endsnippet


context "math()"
snippet '(?<!\\)(mu|alpha|sigma|rho|beta|gamma|delta|zeta|eta|theta|iota|kappa|vartheta|lambda|nu|pi|rho|tau|upsilog|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Pi|Sigma|Upsilon|Phi|Psi|Omega|ell)' "ln" irw
\\`!p snip.rv = match.group(1)`$0
endsnippet


context "math()"
snippet veps "epsilon" wA
\varepsilon
endsnippet

priority 300
context "math()"
snippet int "integral" wA
\int ${1:${VISUAL}}$0
endsnippet

priority 200
context "math()"
snippet '(?<!\\)(arcsin|arccos|arctan|arccot|arccsc|arcsec|pi|zeta)' "ln" rw
\\`!p snip.rv = match.group(1)`
endsnippet

priority 100
context "math()"
snippet to "to" iA
\to 
endsnippet

priority 1000
context "math()"
snippet xto "to" iA
\xrightarrow{$1}$0
endsnippet

context "math()"
snippet mpt "mapsto" iA
\mapsto 
endsnippet


context "math()"
snippet >> ">>" iA
\gg
endsnippet

context "math()"
snippet << "<<" iA
\ll
endsnippet

context "math()"
snippet set "set" wA
\left\\{ $1 \right\\}$0
endsnippet

context "math()"
snippet || "mid" iA
 \mid 
endsnippet


context "math()"
snippet cc "subset" Ai
\subset 
endsnippet

context "math()"
snippet pc "subset" Ai
\supset 
endsnippet

context "math()"
snippet nin "not in " iA
\notin 
endsnippet

context "math()"
snippet not "not in " iA
\not 
endsnippet

context "math()"
snippet inn "in " iA
\in 
endsnippet

context "math()"
snippet NN "n" iA
\mathbb{N}
endsnippet

context "math()"
snippet FF "n" iA
\mathbb{F}
endsnippet

context "math()"
snippet KK "n" iA
\mathbb{K}
endsnippet

context "math()"
snippet cap "cap" iA
\cap 
endsnippet

context "math()"
snippet cup "cup" iA
\cup 
endsnippet


context "math()"
snippet uuu "bigcup" iA
\bigcup_{${1:i \in ${2: I}}}$0
endsnippet

snippet nnn "bigcap" iA
\bigcap_{${1:i \in ${2: I}}}$0
endsnippet


context "math()"
snippet OO "emptyset" iA
\emptyset
endsnippet

context "math()"
snippet RR "real" iA
\mathbb{R}
endsnippet

context "math()"
snippet MM "real" iA
\mathbb{M}
endsnippet

context "math()"
snippet QQ "Q" iA
\mathbb{Q}
endsnippet

context "math()"
snippet CC "C" iA
\mathbb{C}
endsnippet

context "math()"
snippet ZZ "Z" iA
\mathbb{Z}
endsnippet

context "math()"
snippet <! "normal" iA
\triangleleft 
endsnippet

context "math()"
snippet <> "hokje" iA
\diamond 
endsnippet


context "math()"
snippet '(?<!i)sts' "text subscript" irA
_\text{$1}$0
endsnippet

context "math()"
snippet tt "text" iA
\text{$1}$0
endsnippet

context "math()"
snippet case "cases" wA
\begin{cases}
	$1
\end{cases}
endsnippet


snippet bigfun "Big function" iA
\begin{align*}
	$1: $2 &\longrightarrow $3 \\\\
	$4 &\longmapsto $1($4) =$0
.\end{align*}
endsnippet

snippet nvec "column vector" iA
\begin{bmatrix} $1 \end{bmatrix}
endsnippet

snippet cvec "column vector" iA
\begin{bmatrix} ${1:x}_${2:1}\\\\ \vdots\\\\ $1_${2:n} \end{bmatrix}
endsnippet

priority 10
context "math()"
snippet "bar" "bar" riA
\overline{$1}$0
endsnippet

priority 10
context "math()"
snippet "wdt" "bar" riA
\widetilde{$1}$0
endsnippet

priority 100
context "math()"
snippet "([a-zA-Z]|\\mu|\\alpha|\\sigma|\\rho|\\beta|\\gamma|\\delta|\\zeta|\\eta|\\varphi|\\varepsilon|\\epsilon|\\theta|\\iota|\\kappa|\\vartheta|\\lambda|\\nu|\\pi|\\rho|\\tau|\\upsilon|\\phi|\\chi|\\psi|\\omega|\\Gamma|\\Delta|\\Theta|\\Lambda|\\Xi|\\Pi|\\Sigma|\\Upsilon|\\Phi|\\Psi|\\Omega)bar" "bar" riA
\overline{`!p snip.rv=match.group(1)`}
endsnippet

priority 100
context "math()"
snippet "([\\|a-z|A-Z|0-9|'|_|^]*)hat" "hat" riA
\hat{`!p snip.rv=match.group(1)`$1}
endsnippet

priority 100
context "math()"
snippet "([\\|a-z|A-Z|0-9|'|_|^])sps" "hat" riA
($1, \mathcal{${1:`!p snip.rv=match.group(1)`}})$0
endsnippet

snippet sproc "Description" i
$\{X_t:t\in T\}$
endsnippet

snippet probs "Description" i
$(\Omega,\mathcal{F},\mathbb{P})$
endsnippet

snippet probs "Description" i
$(\Omega,\mathcal{F},\mathbb{P})$
endsnippet

snippet msrs "Description" i
$(\Omega,\mathcal{F})$
endsnippet

snippet let "let" b
Let $$1$ be a $2
endsnippet

snippet letx "let omega" bA
Let $X$ be a space
endsnippet

snippet lettau "Description" bA
Let $(X,\tau)$ be a topological space
endsnippet

snippet letdp "Description" bA
Let $(X,\succsim)$ be a decision problem
endsnippet

snippet letcdp "Description" bA
Let $(X,\succsim)$ be a convex decision problem
endsnippet

snippet letker "Description" bA
kernel from $(X,\mathcal{X})$ to $(F,\mathcal{F})$
endsnippet


snippet letprob "Description" bA
Let $X$ be a r.v. taking values in $\overline{\mathbb{R}}$ with distribution $\mu$.
endsnippet

priority 100
context "math()"
snippet "\b([a-zA-Z])ii" "?i" riA
`!p snip.rv=match.group(1)`_i
endsnippet

priority 100
context "math()"
snippet "([a-zA-Z]|\\mu|\\alpha|\\sigma|\\rho|\\beta|\\gamma|\\delta|\\zeta|\\eta|\\varphi|\\varepsilon|\\epsilon|\\theta|\\iota|\\kappa|\\vartheta|\\lambda|\\nu|\\pi|\\rho|\\tau|\\upsilon|\\phi|\\chi|\\psi|\\omega|\\Gamma|\\Delta|\\Theta|\\Lambda|\\Xi|\\Pi|\\Sigma|\\Upsilon|\\Phi|\\Psi|\\Omega)jj" "?j" riA
`!p snip.rv=match.group(1)`_j
endsnippet


priority 101
context "math()"
snippet "([a-zA-Z]|\\mu|\\alpha|\\sigma|\\rho|\\beta|\\gamma|\\delta|\\zeta|\\eta|\\varphi|\\varepsilon|\\epsilon|\\theta|\\iota|\\kappa|\\vartheta|\\lambda|\\nu|\\pi|\\rho|\\tau|\\upsilon|\\phi|\\chi|\\psi|\\omega|\\Gamma|\\Delta|\\Theta|\\Lambda|\\Xi|\\Pi|\\Sigma|\\Upsilon|\\Phi|\\Psi|\\Omega)ii" "?i" riA
`!p snip.rv=match.group(1)`_i
endsnippet


priority 100
context "math()"
snippet "([a-zA-Z]|\\mu|\\alpha|\\sigma|\\rho|\\beta|\\gamma|\\delta|\\zeta|\\eta|\\varphi|\\varepsilon|\\epsilon|\\theta|\\iota|\\kappa|\\vartheta|\\lambda|\\nu|\\pi|\\rho|\\tau|\\upsilon|\\phi|\\chi|\\psi|\\omega|\\Gamma|\\Delta|\\Theta|\\Lambda|\\Xi|\\Pi|\\Sigma|\\Upsilon|\\Phi|\\Psi|\\Omega)nn" "?j" riA
`!p snip.rv=match.group(1)`_n
endsnippet

snippet dfun "Definition of function" iA
$1\colon ${2:\mathbb{R}} \to ${3:\mathbb{R}}, ${4:x} \mapsto$0
endsnippet

# mathop 

context "math()"
snippet EE "Expectation" iA
\mathop{{}\mathbb{E}}_{$1}$0
endsnippet

context "math()"
snippet PP "Probability" iA
\mathop{{}\mathbb{P}}
endsnippet

context "math()"
snippet var "variance" iA
\mathop{\text{Var}}
endsnippet

context "math()"
snippet diag "variance" iA
\mathop{\text{diag}}
endsnippet

context "math()"
snippet cov "covariance" iA
\mathop{\text{Cov}}\left[${1},${2} \right]$0
endsnippet

context "math()"
snippet corr "covariance" iA
\mathop{\text{corr}}\left[${1},${2} \right]$0
endsnippet


context "math()"
snippet unif "unif" iA
\mathop{\text{Unif}}\left( $1 \right)$0
endsnippet

context "math()"
snippet eig "eigenvalues" iA
\mathop{\text{eig}}\left($1\right)$0
endsnippet

context "math()"
snippet rank "rank" iA
\mathop{\text{rank}}\left( $1 \right)$0
endsnippet

context "math()"
snippet span "span" iA
\mathop{\text{span}}
endsnippet

context "math()"
snippet conv "conv" iA
\mathop{\text{conv}}
endsnippet

context "math()"
snippet mod "conv" iA
\left( \mathop{\text{mod}} $1 \right)$0
endsnippet

context "math()"
snippet dim "dim" iA
\mathop{\text{dim}} 
endsnippet

priority 101
context "math()"
snippet codim "dim" iA
\mathop{\text{codim}} 
endsnippet

context "math()"
snippet range "trace" iA
\mathop{\text{ran}}
endsnippet

context "math()"
snippet tr "trace" iA
\mathop{\text{tr}}\left( $1 \right)$0
endsnippet

context "math()"
snippet det "determine" iA
\mathop{\text{det}}\left( $1 \right)$0
endsnippet

context "math()"
snippet Re "Graph" iA
\Re($1)$0
endsnippet

context "math()"
snippet Im "Im" iA
\Im($1)$0
endsnippet

context "math()"
snippet Gr "Graph" iA
\mathop{\text{Gr}}
endsnippet

context "math()"
snippet Adh "Adherence" iA
\mathop{\text{Adh}}
endsnippet

context "math()"
snippet Int "Interior" iA
\mathop{\text{Int}}
endsnippet


context "math()"
snippet vph "var phi" iA
\varphi
endsnippet

priority 100
context "math()"
snippet "([\\|a-z|A-Z|0-9|'|_|^|{|}]*)seq" "sequence" riA
(`!p snip.rv=match.group(1)`_{i})_{i \in \mathbb{N}^*}$0
endsnippet

priority 100
context "math()"
snippet "([\\|a-z|A-Z|0-9|'|_|^]*)bf" "mathbf" riA
\bm{`!p snip.rv=match.group(1)`$1}$0
endsnippet

snippet tex "latex code" b

::: {.latex}
$1
:::

endsnippet

snippet lem "lemma" b

::: {.lemma ${1:#label} name="${2}"}

${3:${VISUAL}}

:::

endsnippet


snippet thm "theorem" b

::: {.theorem ${1:#label} name="${2}"}

${3:${VISUAL}}

:::

endsnippet

snippet def "definition" b

::: {.definition ${1:#label} name="${2}"}

${3:${VISUAL}}

:::

endsnippet


snippet cor "corollary" b

::: {.corollary ${1:#label} name="${2}"}

${3:${VISUAL}}

:::

endsnippet

snippet exm "example" b

::: {.example ${1:#label} name="${2}"}

${3:${VISUAL}}

:::

endsnippet

snippet exr "example" b

::: {.exercise ${1:#label} name="${2}"}

${3:${VISUAL}}

:::

endsnippet


snippet cnj "example" b

::: {.conjecture ${1:#label} name="${2}"}

${3:${VISUAL}}

:::

endsnippet

snippet prp "example" b

::: {.proposition ${1:#label} name="${2}"}

${3:${VISUAL}}

:::

endsnippet


snippet prof "proof" b

:::: {.proof}

${1:${VISUAL}}

::::

endsnippet

snippet rmar "proof" b

::: {.remark}

${1:${VISUAL}}

:::

endsnippet

snippet solu "proof" b

::: {.solution}

${1:${VISUAL}}

:::

endsnippet

snippet rcod "r-code" bA
\`\`\`{r}
$1
\`\`\`
endsnippet

snippet eq "example" b

\begin{equation}
	${1:${VISUAL}}
(\#eq:$2)
\end{equation}$0

endsnippet


snippet cref "cross reference" wA
\@ref(${1}:${2})$0
endsnippet

# 上一个单词转换成小写
snippet "([^\s]\w+)\.lower" "Lowercase(postfix)" rA
`!p snip.rv = match.group(1).lower()`$0
endsnippet

snippet "([^\s]\w+)\.capze" "capitalize(postfix)" rA
`!p snip.rv = match.group(1).capitalize()`$0
endsnippet


context "math()"
snippet inv "inverse" iA
^{-1}
endsnippet

context "math()"
snippet cpl "complement" iA
^c
endsnippet


context "math()"
snippet 11 "indicator" iA
\bm{1}_{$1}$0
endsnippet

context "math()"
snippet eces "complement" iA
^e
endsnippet

context "math()"
snippet bigopt "Optimization problem" iA
\begin{aligned}
	\min &\quad ${1:f(x)}\\\\
	\text{s.t.} &\quad ${2:g(x)} \leq 0\\\\
				&\quad ${3:h(x)} = 0\\\\
\end{align*}
endsnippet

context "math()"
snippet bigmax "Optimization problem" iA
\begin{aligned}
	\max \quad & ${1:f(x)}
	\\\\s.t. \quad & ${2:g(x)} = 0
\end{aligned}
endsnippet

context "math()"
snippet st "such that" w
s.t.
endsnippet

context "math()"
snippet ie "i.e." w
i.e.
endsnippet

context "math()"
snippet ae "a.e." w
a.e.
endsnippet

context "math()"
snippet as "a.s." w
a.s.
endsnippet

context "math()"
snippet rv "i.e." w
r.v.
endsnippet

context "math()"
snippet chf "Description" w
ch.f.
endsnippet

context "math()"
snippet io "infinite often" w
\text{ i.o.}
endsnippet

context "math()"
snippet ult "ultimately" w
\text{ ult.}
endsnippet

context "math()"
snippet wrt "with respect to" w
w.r.t.
endsnippet

context "math()"
snippet iid "identical independent distribution" w
i.i.d.
endsnippet

context "math()"
snippet df "distribution function" w
d.f.
endsnippet

priority 102
snippet wlog "Description" wA
WLOG
endsnippet

priority 102
snippet tfae "Description" wA
TFAE
endsnippet

snippet tctp "Description" wA
This completes the proof.
endsnippet

snippet ttcf "Description" wA
Then the claim follows.
endsnippet

context "math()"
snippet % "percent" iA
\%
endsnippet

context "math()"
snippet Lp "Description" wA
L^p
endsnippet

context "math()"
snippet and "and" wA
\text{ and }
endsnippet

context "math()"
snippet or "and" wA
\text{ or }
endsnippet

context "math()"
snippet over "and" iA
\overset{$1}{$2}
endsnippet

# Markdown syntax

snippet ch "section #" bA
# 
endsnippet

snippet sc "section ##" bA
## 
endsnippet

snippet ssc "section ###" bA
### 
endsnippet

snippet sssc "section ####" bA
#### 
endsnippet

snippet enum "Enumerate" b
1.	
	$1
2.	
	$2
endsnippet

snippet item "Itemize" bA
-	$1
-	$0
endsnippet

snippet EM "Emph" wA
**$1**$0
endsnippet

snippet LD "Lead" wA
*$1*$0
endsnippet

snippet newl "new line" b
<br>
endsnippet

snippet slink "url" i
[$1]($2)
endsnippet

